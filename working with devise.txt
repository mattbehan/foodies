working with devise

# devise comes wit the methods:
# current_user - returns the current user
# user_signed_in - same as authenticated?
#sign_in(@user) and sign_out(@user) - devise created methods that will either sign users in our out
# user_session - returns metadata... by and large DO NOT USE

seed using 
user = user.create()
user.confirm! <-- uses the devise method confirm


allowing users to sign in via email or password is complicated but shouldn't take long
for more info -->
https://github.com/plataformatec/devise/wiki/How-To:-Allow-users-to-sign-in-using-their-username-or-email-address

we allow unconfirmed access by toggling it in the initializer. it defaults to two months. This allows unconfirmed users to still login


overwrite after_inactive_sign_up_path_for in the devise controller to edit the default path
alternative would be to just set devise_for :users, controllers: { registrations: "reg`istrations" } in routes.rb, then overwriting the method in my own registrationscontroller that inherited from devisecontroller, however that never responded to any changes
update- fix was to say registrationsController <Devise::RegistrationsController and not DeviseController
it still responds to after_sign_up_path_for and not after_inactive_sign_up_path_for, probably because they are allowed to use the site for 7 days as I set it in config

when we want to push to production all we will have to do is set the environment variables for sendgrid username and password using-
heroku config:set SENDGRID_USERNAME

config.scoped_views

________________
DEVISE INVITABLE

route for sending an invitation is users/invitation/new-- set a before_filter on that

had to copy invitations controller which lets me override the default devise mailer so I can use my custom methods in my InviteMailer model.

Created custom views in views/invite_mailer/reviewer_invitation_instructions and views/invite_mailer/user_invitation_instructions so I can customize the messages

copied in notification mailer in order to create absolutely custom messages... e.g. the user would be able to say "hey! whats up remember when I met you five days ago! This is actually a personalized message!" ... doesn't look like this was actually necessary

I think this all would have been a lot easier if I had just passed in the params for the user to be a certain type of admin in attributes... then all I would have to do is say invite!({attributes})



___________
OMNIAUTH

will have to change the callback url when in production

config/initializers/devise.rb
	add in keys for for config.omniauth
add in omniauthable in devise model

set up omniauth callbacks controller that inherits from devise::omniauthcallbacks

specify in routes that :omniauth_callbacks will handle "omniauth_callbacks"

alias method all and point the providers as methods

omniauth.auth is a hash of information

find or create a user from the information in the hash


add uid to users -- an alternative would be to create an alternative model and store the identity assocations in there

create a method that is a class method on the user model that takes the auth hash, looks through it and grabs the provider and the uid.
	then it looks for User where the credentials match 


get the users credentials from User.from_omniauth(), then sign the user in on that login form
	to do so we need to override a devise class method called new_with_session
		in this method, we look to see if session["devise.user_attributes"] has been set, and if so we create a new user and set that users attributes to the params. since we trust the hash we do not need to set protection
		if there is nothing in session["devise.user_attributes"], then we just call the super method

only display password fields on the signup form if the provider is not present if the validations fail (e.g. email is not present)

similarly, if the encrypted password is blank, we should remove the current_password field from the edit form

____________________________
ISSUES
when invitation is accepted, user is not redirected to update their information
